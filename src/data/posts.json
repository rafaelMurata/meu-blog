[
  {
    "id": "1",
    "slug": "Brief description of the importance of unit testing and the evolution of tools and frameworks to perform these tests in Java applications.",
    "title": "Unit Testing: Comparing Spring Boot and Traditional Approaches",
    "body": "## What are Unit Tests?\nThey are codes written with the aim of testing, applied to their classes and methods, providing different scenarios for their behaviors. Increasing software correctness and quality. Favoring simplicity, practicality, cost and immediate feedback on the target code.\nBy applying these techniques, software systems favor regression testing and the discovery of possible unwanted behaviors \"bugs\". Depending on the size and complexity of the system, it may require a lot of effort to apply the test cases.\n\n## Difference between unit, integration and system testing and end-to-end\nIn unit testing, the objective is to test small units of code and receive feedback on their quality. Integration tests focus on the interaction between two or more units. In both cases the objective is to provide better quality and correctness of the software.\nIn end-to-end tests, the object is to simulate the behavior of the system as a whole, generally using a significant amount of time for execution, also known as acceptance tests.\n\n## A convention for testing:\nIn unit testing, the convention/pattern of Arrange (or Setup), Act (or Exercise) and Assert (or Verify) is generally followed.\nFor example:\n``````\nNow, let's write a unit test for this class:\n\n``````\nIn this example:\n\n**Setup/Arrange:** We create an instance of the Calculator class and define the values that we will use in the test.\n**Exercise/Act:** We invoke the method we want to test and get the result.\n**Verify/Assert:** We check whether the result obtained corresponds to what we expected. If it doesn't match, the test fails.\n\nThis structure helps keep the test clear and helps you understand what each part of the test is doing.\n\n## Testing with Spring Boot:\n\n**Benefits of using Spring Boot for unit testing**\nSimplified Configuration: Leveraging configuration convention.\nSpring Boot Test: A tool that integrates common testing libraries such as JUnit and TestNG.\nIntegrated Mocks: Using **@MockBean** to create mock versions of Spring components, such as repositories or services.\n\n\n**Creating a Unit Test with Spring Boot**\n\nLet's assume we have a service in Spring Boot called GreetingService:\n``````\nIn this Spring Boot example, the Spring test context is loaded, and the GreetingService is automatically injected into the test, making it easier to test Spring components.\n\n``````\nRemember, these are simple examples for demonstration. In real projects, you will probably have more complex cases, such as interaction with databases, calls to external APIs, among others. For these scenarios, you would use other Spring Boot Test functionality, such as **@MockBean** to create mock Spring beans or **TestRestTemplate** to test REST endpoints.\n\n**Example usage for @MockBean**\n\n@MockBean is a Spring Boot Test annotation, used to add mocks within a Spring test context. It is used to create a mocked version of a bean within the Spring context and can be useful for decoupling your tests from external components such as databases, external services, among others.\n\nSuppose you have a service that retrieves information from a repository:\n``````\nNow, if we want to test the UserService without actually querying the database, we can mock the UserRepository:\n\n``````\nIn the example above, when using @MockBean, the real UserRepository is replaced in the test context by the mock, and then we configure this mock to return a specific user when the findById method is called.\n\n**TestRestTemplate**\n\nTestRestTemplate is a Spring Boot Test class that makes it easy to make HTTP calls in integration tests.... With it, you can test your REST endpoints the same way a customer would, but within the test environment.\nSuppose you have the following controller:\n``````\nNow, you can test this controller using TestRestTemplate:\n``````\nIn the test above, we configured the userService to return a mocked user. We then use TestRestTemplate to make a GET call to our endpoint and verify that the response is as expected.\n\n## Testing without Spring boot:\n\nSuppose we have a simple class called Calculator:\n``````\nHere is a basic unit test for this class using JUnit:\n\n``````\n\n## Comparison: Spring Boot vs.... Traditional Approach\n**Pros and Cons of Testing with Spring Boot**\nPros:\n\nEasy integration with the Spring ecosystem.\nConventions and automatic configuration reduce boilerplate code.\nRobust support for integration testing.\n\nCons:\n\nIncreased initialization time for tests due to the Spring context.\nThe learning curve for developers unfamiliar with Spring.\n\n**Pros and Cons of Testing without Spring Boot**\nPros:\n\nFaster initialization, as it does not load the Spring context.\nMore generic approach that can be applied to any Java application.\n\nCons:\n\nMore manual configuration and boilerplate code.\nFewer tools and integrations available out of the box.\n\n## Conclusion\nReflection on the importance of choosing the right approach based on the needs of the project. Both approaches have their merits, and the choice between Spring Boot and traditional methods must consider the nature of the application, the team's experience, and specific testing requirements.\nEnsuring software quality is generally a slow and costly process, although these types of approaches favor a reduction in the defect rate.\nAs technology advances, new tools and techniques continue to emerge, making the process of ensuring software quality increasingly refined.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-09-20T14:51:18.706Z",
    "tags": ["Java", "Spring Boot", "Unit Testing"]
  },
  {
    "id": "2",
    "slug": "Accidentally committing sensitive information to a public repository can be a serious concern, especially if it's information like API keys, database credentials, or other secrets. If you've deleted the file in a new commit, the sensitive information will still exist in the commit history.",
    "title": "Committing sensitive information",
    "body": "## committing sensitive information\n\nAccidentally committing sensitive information to a public repository can be a serious concern, especially if it's information like API keys, database credentials, or other secrets. If you've deleted the file in a new commit, the sensitive information will still exist in the commit history.\n\n## Here are the steps you should take to fix this situation:\n\n``````\nReplace PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA with the path of your .env file.\n\n## Force Push\nForce Push to Remote Repository (this step is destructive and will overwrite the history in the remote repository. Make sure all collaborators get a new copy of the history afterwards):\n\n``````\nIf you have tags, also force push them:\n\n``````\n## Add the .env file to your .gitignore to avoid accidental future commits:\n\n``````\n\n## Reset Keys and Passwords: \n\nIf your .env file contained keys, tokens, or passwords, you should consider all of that information to be compromised. Go to the corresponding services and reset all this information.\n\n## Use Secret Management Tools: \n\nIn the future, consider using tools like [GitHub's Secrets] (https://docs.github.com/en/actions/security-guides/encrypted-secrets) or services like AWS Secrets Manager to manage sensitive information. They allow you to use sensitive information in your code without actually exposing it.\n\n## Note: \n\nThe filter-branch tool is powerful but can be destructive. Make sure you have a full backup of your repository before running commands that change history. If you're not comfortable with these operations, consider asking a colleague with more Git experience for help.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-08-22T17:29:30.637Z",
    "tags": ["Git", "Security", "Best Practices"]
  },
  {
    "id": "3",
    "slug": "Java EE, released in 1999 as J2EE, has evolved over the years, resulting in its transition to Jakarta EE under the Eclipse Foundation in 2017. The platform has been central to the development of robust enterprise applications.",
    "title": "History and Evolution of Java EE",
    "body": "## Introduction:\nJava Enterprise Edition (Java EE), formerly known as Java 2 Platform, Enterprise Edition (J2EE), is a set of specifications and standard practices aimed at developing enterprise applications in Java. The platform provides an API and runtime environment for developing large-scale, multi-tier, scalable, reliable, secure, and fault-tolerant applications. Over the years, Java EE has evolved significantly to meet the growing demands of the IT industry.\n\n## Origins and J2EE:\nJ2EE was released in 1999 by Sun Microsystems as an extension to the Java 2 Standard Edition (J2SE) platform. The goal was to provide a standard framework for developing scalable, reliable, and secure distributed applications. This first version brought components such as Servlets, JavaServer Pages (JSP) and Enterprise JavaBeans (EJB).\n\n## Evolution and Main Versions:\n\n**J2EE 1.3 (2001)**: This release improved the EJBs and introduced the Connector Architecture, making it easier to integrate with legacy systems.\n\n**J2EE 1.4 (2003)**: It was in this version that the web service started to gain ground, with J2EE offering native support for SOAP and web services via JAX-RPC.\n\n**Java EE 5 (2006)**: In a significant change, J2EE was renamed Java EE. This release simplified development by introducing annotations and the Java Persistence API (JPA). Also, the release brought a new approach to EJBs with the introduction of EJB 3.0.\n\n**Java EE 6 (2009)**: This release introduced the Web profile, allowing developers to create lightweight web applications without the need for EJBs. It also introduced APIs such as JAX-RS for RESTful web services and CDI for dependency injection.\n\n**Java EE 7 (2013)**: With a focus on productivity and meeting modern trends, it brought improvements to websockets, JSON processing, and batch processing.\n\n**Java EE 8 (2017)**: Focused on modernizing the platform, introduced new features for developing microservices, improved support for RESTful APIs, and brought the new JSON-B API for JSON binding.\n\n## Transition to the Eclipse Foundation:\n\nAfter Oracle's acquisition of Sun Microsystems, there was growing concern in the community about the future of Java EE. In 2017, Oracle decided to transfer the management and direction of Java EE to the Eclipse Foundation, giving rise to Jakarta EE. This change represented a new chapter in the history of Java EE, ensuring a more open and participatory governance.\n\n## Conclusion:\nThe trajectory of Java EE reflects the development and changes in the software industry over the last few decades. From its origins as J2EE to its rebranding and transition to the Eclipse Foundation as Jakarta EE, Java EE has been instrumental in building robust, scalable enterprise applications.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-08-22T17:42:58.396Z",
    "tags": ["Java EE", "Jakarta EE", "Enterprise Java"]
  },
  {
    "id": "4",
    "slug": "RabbitMQ is one of the most popular messaging systems based on the AMQP (Advanced Message Queuing Protocol) protocol. It offers an effective way to build decoupled and scalable applications. In this article, we'll explore how RabbitMQ can be integrated into Java applications.",
    "title": "Integration of RabbitMQ with Java",
    "body": "## JMS\n\nThe JMS (Java Messaging Service) specification defines a standard API for Java programs so that they can interact with Message Brokers. Developed under the umbrella of the Java Community Process (JCP), the JMS provides a standard set of interfaces and classes that developers can use to send and receive messages between distributed applications. Among the best known are HornetQ (Red Hat), IBM MQ (IBM), Oracle WebLogic JMS (Oracle) and Apache MQ (Open-source).\n\n## Message Broker\n\nA Message Broker is software that enables applications, systems and services to exchange information, translating messages from the producer format to the consumer format. The term \"middleware\" refers to software that works between systems or applications, facilitating communication between them. In this context, \"messaging middleware\" or \"MOM\" (message-oriented middleware) is a specialized type of middleware specifically designed to manage the transmission of messages between systems. Some examples of Brokers are RabbitMQ, Apache Kafka, ActiveMQ and MQTT (Mosquitto).\n\n## AMQP\n\nAMQP serves as a standard and interoperable communication bridge (As it is a standard protocol, it allows different systems) regardless of specific middleware to communicate effectively. When we combine APIs like JMS and implementing a Message Broker, it allows developers to build robust systems and be able to communicate effectively across distributed and heterogeneous systems.\n \nTherefore, AMQP is a message protocol that allows applications to communicate, through messages, using a middware broker. The broker receives the message from a publisher (also known as producers) and routes it to a consumer (application that processes the message).\n\n## Why RabbitMQ?\n\n**Decoupling**: RabbitMQ allows message producers and consumers to operate independently, without needing to know each other's details.\n\n**Scale**: It supports distributing messages across multiple consumers, allowing for parallel processing.\n\n**Resilience**: Messages can be stored and resent in case of failure, ensuring that no message is lost.\n\n## Configuring RabbitMQ in Java:\n\nDependencies: To use RabbitMQ with Java, you need to add the client library. In Maven, add the following to your pom.xml:\n\n``````\n\nConnection: Establish a connection to the RabbitMQ server.\n\n``````\n\nPublishing Messages:\nWith the connection established, you can create a channel and post messages.\n\n``````\nConsuming Messages:\nTo consume messages, you need to define a Consumer and associate it with a queue.\n\n``````\n\n## Conclusion:\nRabbitMQ offers a robust and scalable solution for inter-system communication. By integrating it with Java, applications can benefit from reliable messaging, making it easier to build resilient distributed systems. This event-driven approach, also known as \"Event-Driven\", is essential in modern environments where reactivity and the ability to respond to real-time events is crucial. Utilizing RabbitMQ, organizations can effectively adopt event-driven architecture, allowing systems to interact asynchronously and quickly adapt to changes and demands in the environment. In summary, combining Java with RabbitMQ is a step towards a more flexible, responsive and adaptable architecture.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-08-22T23:20:54.862Z",
    "tags": ["Java", "RabbitMQ", "Messaging", "AMQP"]
  },
  {
    "id": "5",
    "slug": "This article details the use of the @FunctionalInterface annotation, the main interfaces in the \"java.util.function\" package, and covers the concept of \"target typing\". These additions not only provide cleaner code, but also allow for more reactive design approaches, streamlining Java development.",
    "title": "Functional Interfaces: An Overview and Guide",
    "body": "## Introduction\n\nJava over the years has gone through several significant evolutions. One such revolutionary change was the introduction of functional interfaces and lambda expressions in Java 8. These additions not only simplified the code by reducing verbosity, but also opened the door to functional programming in the Java universe.\n\nThe [@FunctionalInterface](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/FunctionalInterface.html) annotation has become a powerful tool, clearly indicating the interfaces that can be used with lambda expressions, ensuring they have only one abstract method. This simplification, combined with the ability of lambda expressions to concisely represent instances of functional interfaces, has brought a new dimension to writing Java code.\n\nIn this article, we'll explore the concept of functional interfaces, their main forms, how to work with lambda expressions, and why they are so essential to modern Java development.\n\n``````\n\nWe now demonstrate the use of a functional interface with a lambda expression:\n\n``````\n\n## Key Functional Interfaces\n\nThe [Key Functional Interfaces](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/package-summary.html) refer to some predefined interfaces that are provided in the \"java.util.function\" package since java 8.\n\n**`java.util.function.Predicate<T>`**: That accept an object of generic type T and returns a boolean.\n\n Main method: boolean test(T t)\n\n**`java.util.function.Function<T,R>`**: That takes an object of generic type T and returns a value of type R.\n\n Main method: R apply(T t)\n\n**`java.util.function.Consumer<T>`**: That takes an object of generic type T and returns no result (void).\n\n Main method: void accept(T t)\n\n**`java.util.function.Supplier<T>`**: This takes no value and returns a value of type T.\n\n Main method: T get()\n\n## Using Lambda Expressions in Java\n\nNow that we've got a basic understanding, let's see lambda expressions in action:\n\n**Predicate:**\n\n``````\n\n**Function:**\n\n``````\n\n**Consumer:**\n\n``````\n\n**Supplier:**\n\n``````\n\n## Target Typing\n\nThe concept of \"target typing\" refers to the compiler determining the type of a lambda expression based on the context in which it is used. For example:\n\n``````\nSo in the second example, the Java compiler knows the expected result, as we are trying to create an instance of the \"Comparator\". So the compiler can infer the types for the parameters \"name1\" and \"name2\" as \"String\". This feature is useful as it makes the code less verbose and cleaner.\n\n## Different functional interfaces\n\nUsing the \"target typing\" concept, the Callable and PrivilegedAction interfaces both share an abstract signature method.\n\n## Callable\n\nThe Callable interface is similar to the Runnable interface in that both are designed for classes that want to be run by another thread.\n\nReturn: The main difference is that Callable can return a value while Runnable cannot.\nException: Callable can throw a checked exception, while Runnable cannot.\n\n``````\n\n``````\n\n## PrivilegedAction\n\nThis interface is used for security sensitive operations. It is often used in the context of an AccessController to allow code to run with special privileges (such as accessing protected resources).\n\n``````\n\n``````\n\n## Comparator\n\nThe Comparator interface is used mainly for ordering. It is a functional interface that represents an overall order (or a sorting criterion) on some objects of a specific type.\n\n``````\n\n``````\nOr, with a lambda expression:\n\n``````\n\n## Conclusion\n\nFunctional interfaces and lambda expressions have revolutionized the way we write code in Java. These additions to Java 8 not only provide cleaner, more cohesive code, but also leverage functional programming, allowing developers to take advantage of more reactive design patterns and architectures. By understanding and embracing these concepts, developers can build more efficient, readable, secure, and scalable applications.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-08-24T22:56:33.027Z",
    "tags": ["Java", "Functional Interfaces", "Lambda Expressions"]
  },
  {
    "id": "6",
    "slug": "When it comes to object-oriented programming, the word abstract is one of the fundamental pillars. In Java, the word abstract is one of the main mechanisms for achieving this abstraction.",
    "title": "Understanding the abstract Keyword in Java",
    "body": "## What is data abstraction?\nIn computer science, abstraction represents one of the fundamental principles, it refers to the process of hiding complex and unnecessary details of the system, aiming at high-level concerns about functionalities.\n\n## What does abstract mean in Java?\nIn simple terms, abstract is a keyword that indicates that something is incomplete or cannot be instantiated directly. In the context of Java, you can find abstract classes and methods.\n\n## Abstract Classes\nA class marked as abstract cannot be instantiated directly, but they can be subclassed. When an abstract class is subclassed, the subclass usually provides implementations for all abstract methods in its parent class. However, if this does not happen, the subclass must also be declared abstract.\n\nIn other words, you cannot create an object of this class using the new operator. An abstract class is generally used as a base class for other classes.\n\n``````\nIn this example, Animal is an abstract class that has an abstract method called sound.\n\n## Abstract Methods\n\nAn abstract method is a method that has no body. He only has one statement. If a class has even just one abstract method, the entire class must be declared abstract.\n``````\nHere, sound is an abstract method. Classes that extend Animal need to provide an implementation for this method.\n\n## Why Use abstract?\nThe idea behind abstract classes and methods is to provide a structure. Abstract classes allow you to define methods that must be implemented by subclasses, thus guaranteeing a specific contract that subclasses must follow.\n\nFor example:\n``````\nHere, both Dog and Cat are subclasses of Animal and both provide their own implementation of the sound method.\n\n## Important Considerations\n* An abstract class can have variables, constructor methods and concrete methods (methods with body).\n* If a subclass does not provide implementations for all of the abstract methods of the abstract parent class, then the subclass must also be marked as abstract.\n* Abstract methods cannot be private or final.\n* A class cannot be both abstract and final.\n\n## Conclusion\nThe abstract keyword provides a powerful mechanism for abstraction in Java. It helps ensure a contract between base classes and subclasses, allowing for a clear structure and facilitating code maintenance and expansion. By understanding and correctly using abstract classes and methods, developers can create more modular and scalable systems.",
    "imageUrl": "",
    "authorId": "64e3a39ce3b3be9307087667",
    "createdAt": "2023-10-18T21:46:07.633Z",
    "tags": ["Java", "Abstraction", "Object-Oriented Programming"]
  }
]
